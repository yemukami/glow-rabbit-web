# 懺悔ログ

## 2025-12-xx (BLE接続表示の不整合)
- 事象: BLE切断時にステータス/ボタンが未接続表示に戻らず、ユーザーに接続状態の誤認リスクがあった。
- 原因: `connectBLE` のPromise失敗/成功時にステータス更新を保証しておらず、切断時のUI更新を逃していた。
- 対応: 接続ハンドラをasync化し、成功/失敗どちらでも `updateConnectionStatus(false/true)` を確実に呼ぶよう修正。
- 再発防止: コネクション状態を持つUIはPromise結果/例外経路の両方で更新すること。BLE周辺はテスト時にUIログを確認し、手動で切断→接続の表示をチェックする。

## 2025-12-xx (STARTで初期設定が消えるデグレ)
- 事象: START直前の`stopRunner`でキューがクリアされ、展開時に送った色/ペース設定が消滅。2周目以降の点灯指示が届かない。
- 原因: START時の初期設定送信を最適化で省いたまま、高優先度`stopRunner`でキューを全消去していたため、Glow-C側に設定が残らなかった。
- 対応: STARTごとに初期設定を再送するよう暫定回避し、送信順序の見直し（設定同期フェーズとSTARTの分離）を進める。
- 再発防止: 高優先度送信がキューを消すことを前提に、必要な設定はSTART直前か同期フェーズで必ず送る。省略最適化は要件（stopを送らない運用）とセットで導入する。

## 2025-12-xx (同期/START分離の迷走による混乱)
- 事象: 同期とSTARTの最適化を繰り返す中で、設定送信タイミングが揺れ、光らない/遅れるなどのデグレが頻発。
- 原因: Flutter型（同期で設定→START最小）と安全側（STARTで再送＋stop）を往復し、要件を固定せずに変更してしまった。TDDでケース固定をしないまま挙動を動かした。
- 対応: 設定同期とSTARTを明確に分離し、デフォルトはSTART最小・設定未送信時のみ自動送信の安全弁に統一。syncNeededフラグを導入し、同期は明示的に実施する設計に固定。
- 再発防止: 仕様（同期フェーズとSTARTの責務）を固定してから実装し、テストケースを先に定義して往復を防ぐ。stop/high-priorityがキューを消すことを前提にテストを追加し、挙動変更時は必ずログとテストを更新する。
 - 追加: BLE未接続時に同期/STARTを試みた場合も明示的にアラートを出し、無反応に見えないようにする。接続エラー時もUIで通知する。

## 2025-11-30 (全削除時のランタイムエラー)
- 事象: デバイス全削除→同期で `Assignment to constant variable` が発生（isListDirty を直接再代入）。
- 原因: device-manager から import した `isListDirty` が const エクスポートであるのに、UI側で再代入を試みた。
- 対応: `markDeviceListDirty` を導入し、dirtyフラグの更新を専用関数経由に変更。clear時に保存＆dirty化を実施。
- 再発防止: 共有状態を直接再代入しない。mutator関数を用意する。変更後は `node --check` と対象機能の手動確認をセットで行う。

## 2025-11-30 (START時の0m遅れへのワークアラウンド)
- 事象: Glow-R #1 が0mではなく数m先で初点灯するように見える。fw側が startDevIdx を使わず RunnerPointer を初期化しないため、UIの設定が効かない。
- 原因: Glow-Cの startRunner(0x0007) はポインタ/開始位置をリセットせず、初回点灯までDelayがかかる仕様。UI側だけではポインタ位置を制御できない。
- 対応: START前に `commandStopRunner` を送りリセットし、さらに startDevIdx のデバイスに `commandMakeLightUp` で先行点灯（v2.1.0-beta.30）。startPosはfwが無視する可能性をコメントで明示。
- 再発防止/根本策: fw側で startDevIdx を尊重し RunnerPointer を初期化するのが筋。UI側の先行点灯は暫定。fw対応が必要なら別途PR/確認を行う。
- メモ: 現行のワークアラウンドは一時対応であり、fwが修正された場合は本来の実装（fwがstartDevIdxを尊重、RunnerPointer初期化）に戻すことを検討する。

## 2025-12-xx (ペーサー個別停止をUIで近似したが、プロトコル非対応)
- 事象: Flutterが「ペースごとにゴールで止まる」挙動だと認識し、UI側で距離到達後は移動を止める変更を入れたが、BLEの stopRunner は全体停止しかなく、実機では最遅ペースのSTOPまで走り続ける可能性が残る。
- 原因: プロトコルに runner 指定の STOP/PAUSE がなく、UIだけで個別停止を再現しようとしたため、表示と実機挙動が乖離する。
- 再発防止: ペーサー単位の停止/固定表示はFW・プロトコルの対応が必要と明記し、UI側だけで挙動変更しない。必要なら仕様合意を得てから実装変更する。
- 確認: プロトコル定義と Flutter 側の BLE 実装を確認し、stopRunner が全体停止のみであることを再確認。
